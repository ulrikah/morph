{"version":3,"file":"index.53118b30.js","sources":["../../vite/modulepreload-polyfill","../../src/utils/lerp.ts","../../src/utils/map.ts","../../src/utils/random.ts","../../src/io.ts","../../src/utils/shapes.ts","../../src/diff-growth/dg2d.ts","../../src/utils/createCanvas.ts","../../src/dla/Walker.ts","../../src/dla/dla.ts","../../src/index.ts"],"sourcesContent":["const p = function polyfill() {\n    const relList = document.createElement('link').relList;\n    if (relList && relList.supports && relList.supports('modulepreload')) {\n        return;\n    }\n    for (const link of document.querySelectorAll('link[rel=\"modulepreload\"]')) {\n        processPreload(link);\n    }\n    new MutationObserver((mutations) => {\n        for (const mutation of mutations) {\n            if (mutation.type !== 'childList') {\n                continue;\n            }\n            for (const node of mutation.addedNodes) {\n                if (node.tagName === 'LINK' && node.rel === 'modulepreload')\n                    processPreload(node);\n            }\n        }\n    }).observe(document, { childList: true, subtree: true });\n    function getFetchOpts(script) {\n        const fetchOpts = {};\n        if (script.integrity)\n            fetchOpts.integrity = script.integrity;\n        if (script.referrerpolicy)\n            fetchOpts.referrerPolicy = script.referrerpolicy;\n        if (script.crossorigin === 'use-credentials')\n            fetchOpts.credentials = 'include';\n        else if (script.crossorigin === 'anonymous')\n            fetchOpts.credentials = 'omit';\n        else\n            fetchOpts.credentials = 'same-origin';\n        return fetchOpts;\n    }\n    function processPreload(link) {\n        if (link.ep)\n            // ep marker = processed\n            return;\n        link.ep = true;\n        // prepopulate the load record\n        const fetchOpts = getFetchOpts(link);\n        fetch(link.href, fetchOpts);\n    }\n};__VITE_IS_MODERN__&&p();","import paper from \"paper\";\n\nconst lerp = (a: paper.Point, b: paper.Point, force: number): paper.Point => {\n    if (force < 0.0 || force > 1.0) throw \"force must be in range [0.0, 1.0]\";\n    const diff = b.subtract(a);\n    return new paper.Point(a.x + force * diff.x, a.y + force * diff.y);\n};\n\nexport default lerp;\n","export const map = (\n    value: number,\n    a: number,\n    b: number,\n    c: number,\n    d: number\n) => {\n    return ((value - a) * (d - c)) / (b - a) + c;\n};\n","import { map } from \"./map\";\n\nexport const random = (a: number, b: number): number => {\n    return map(Math.random(), 0.0, 1.0, a, b);\n};\n\nexport const randomInt = (min: number, max: number): number => {\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n","import paper from \"paper\";\n\nexport const svgElementFromString = (svgString: string): SVGElement => {\n    let temp = document.createElement(\"template\");\n    temp.innerHTML = svgString.trim();\n    return temp.content.firstChild as SVGElement;\n};\n\nexport const fileFromSvgElement = (\n    svgElement: SVGElement,\n    fileName?: string\n): File => {\n    svgElement.setAttribute(\"xmlns\", \"http://www.w3.org/2000/svg\");\n    svgElement.setAttribute(\"xmlns:xlink\", \"http://www.w3.org/1999/xlink\");\n    return new File(\n        [svgElement.outerHTML],\n        fileName ? fileName : `export_${Date.now()}.svg`,\n        {\n            type: \"image/svg+xml;charset=utf-8\",\n        }\n    );\n};\n\nexport const getDownloadableLink = (file: File): HTMLAnchorElement => {\n    const fileURL = URL.createObjectURL(file);\n    const link = document.createElement(\"a\");\n    link.setAttribute(\"href\", fileURL);\n    link.setAttribute(\"download\", file.name);\n    link.innerText = file.name;\n    return link;\n};\n\nexport const fileUploader = (\n    onFilesUploaded: (files: File[]) => void\n): HTMLElement => {\n    const inputField = document.createElement(\"input\");\n    inputField.setAttribute(\"type\", \"file\");\n\n    // which event type is this?\n    inputField.onchange = (event: any) => {\n        if (event.target && event.target.files.length > 0) {\n            inputField.files = event.target.files;\n            onFilesUploaded(Array.from(event.target.files) as File[]);\n        } else {\n            console.log(\"No files in input field\");\n        }\n        event.preventDefault();\n    };\n    return inputField;\n};\n\nexport const demo = (): HTMLElement => {\n    const addSvgFilesToProject = (files: File[]) =>\n        files.forEach((file: File) => {\n            file.text().then((content) => {\n                const item = new paper.Item().importSVG(\n                    svgElementFromString(content),\n                    {\n                        onload: (_: paper.Item) =>\n                            console.log(\"Imported SVG\", content),\n                    }\n                );\n                item.strokeColor = new paper.Color(\"black\");\n                paper.project.activeLayer.addChild(item);\n                paper.view.update();\n            });\n        });\n    return document.body.appendChild(fileUploader(addSvgFilesToProject));\n};\n","import paper from \"paper\";\n\n// draw points in a square based on a radius\nconst pointsAsSquare = (\n    radius: number,\n    nPointsPerSegment: number,\n    center: paper.Point\n) => {\n    // define the squares\n    const squares: paper.Point[] = [\n        center.clone().add(new paper.Point(radius, -radius)), // top right\n        center.clone().add(new paper.Point(radius, radius)), // bottom right\n        center.clone().add(new paper.Point(-radius, radius)), // bottom left\n        center.clone().add(new paper.Point(-radius, -radius)), // top left\n    ];\n    const points: paper.Point[] = [];\n    [\n        [squares[0], squares[1]],\n        [squares[1], squares[2]],\n        [squares[2], squares[3]],\n        [squares[3], squares[0]],\n    ].map((pair) => {\n        points.push(pair[0]); // push the first square to the list of points\n        const dx = pair[1].x - pair[0].x;\n        const dy = pair[1].y - pair[0].y;\n        for (let i = 0; i < nPointsPerSegment; i++) {\n            points.push(\n                new paper.Point(\n                    pair[0].x + (i / nPointsPerSegment) * dx,\n                    pair[0].y + (i / nPointsPerSegment) * dy\n                )\n            );\n        }\n    });\n    return points;\n};\n\nexport default pointsAsSquare;\n","import paper from \"paper\";\nimport lerp from \"../utils/lerp\";\nimport { random, randomInt } from \"../utils/random\";\nimport { fileFromSvgElement, fileUploader, getDownloadableLink } from \"../io\";\nimport pointsAsSquare from \"../utils/shapes\";\n\nconst DISTANCE_THRESHOLD = 3;\nconst ATTRACTION_FORCE = 0.9;\nconst REPULSION_FORCE = 0.5;\nconst ALIGNMENT_FORCE = 0.5;\nconst ADAPTIVE_SUBDIVISION_THRESHOLD = DISTANCE_THRESHOLD * 2;\nconst OVERCONSTRAIN_FREQUENCY = 2; // provided in frames\nconst DEBUG = false;\n\nconst differentialGrowth = (canvas: HTMLCanvasElement) => {\n    paper.setup(canvas);\n    let doRender = true;\n    let isReady = false;\n\n    const debugText = new paper.PointText({\n        point: new paper.Point(\n            paper.view.viewSize.width / 10,\n            paper.view.viewSize.height / 5 + 50\n        ),\n        justification: \"left\",\n        fontSize: 24,\n        visible: DEBUG,\n    });\n\n    const path = new paper.Path({ strokeColor: \"black\" });\n    path.add(...pointsAsSquare(50, 50, paper.view.center));\n    path.closePath();\n    isReady = true;\n\n    const addSvgFilesToPath = (files: File[]) => {\n        files.forEach((file: File) => {\n            if (file.type.match(\"svg\")) {\n                console.log(\"Trying file\", file.name);\n                file.text().then((content) => {\n                    paper.project.importSVG(content, {\n                        insert: false,\n                        onLoad: (item: paper.Item) => {\n                            path.removeSegments();\n                            // the second child of the SVG items are paths\n                            path.add(\n                                ...upsamplePath(item.children[1] as paper.Path, 500)\n                            );\n                            path.closePath();\n                            path.position = paper.project.view.center;\n                            console.log(`Updating ${paper.view.update()}`);\n                            isReady = true;\n                        },\n                    });\n                });\n            }\n        });\n    };\n\n    const helpText = document.createElement(\"p\");\n    helpText.setAttribute(\"style\", \"font-family: Arial\");\n    helpText.innerText =\n        \"Upload a custom SVG file. The SVG has to be a closed shape with a single path.\";\n    const uploaderElement = fileUploader(addSvgFilesToPath);\n    const fileUploadContainer = document.createElement(\"div\");\n    fileUploadContainer.setAttribute(\n        \"style\",\n        `\n        border: 1px solid black; max-width: 75%;\n        border-radius: 5px;\n        padding: 2% 1% 1% 1%;\n        `\n    );\n    fileUploadContainer.appendChild(uploaderElement);\n    fileUploadContainer.appendChild(helpText);\n    canvas.parentElement?.append(fileUploadContainer);\n\n    paper.view.onFrame = (event: any) => {\n        if (!doRender || !isReady) return;\n        path.segments.forEach((segment) => {\n            // attract\n            [segment.previous, segment.next].forEach((neighbor) => {\n                const l = lerp(segment.point, neighbor.point, ATTRACTION_FORCE);\n                segment.point.x = l.x;\n                segment.point.y = l.y;\n            });\n            // repulsion\n            path.segments\n                .filter((otherSegment) => otherSegment != segment)\n                .forEach((otherSegment) => {\n                    const d = segment.point.getDistance(otherSegment.point);\n                    if (d < DISTANCE_THRESHOLD) {\n                        const diff = segment.point.subtract(otherSegment.point);\n                        segment.point.x += diff.x * REPULSION_FORCE;\n                        segment.point.y += diff.y * REPULSION_FORCE;\n                    }\n                });\n            // alignment\n            const midpoint = lerp(\n                segment.previous.point,\n                segment.next.point,\n                0.5\n            );\n            const l = lerp(segment.point, midpoint, ALIGNMENT_FORCE);\n            segment.point.x = l.x;\n            segment.point.y = l.y;\n        });\n\n        // adaptive suddivision\n        const newPoints: { index: number; point: paper.Point }[] = [];\n        path.curves.forEach((curve, idx) => {\n            if (\n                curve.point1.getDistance(curve.point2) >\n                    ADAPTIVE_SUBDIVISION_THRESHOLD &&\n                newPoints.every(\n                    (newPoint) =>\n                        newPoint.point.getDistance(curve.point1) <\n                            ADAPTIVE_SUBDIVISION_THRESHOLD &&\n                        newPoint.point.getDistance(curve.point2) <\n                            ADAPTIVE_SUBDIVISION_THRESHOLD\n                )\n            ) {\n                const newSegment = curve.getPointAtTime(0.5);\n                newPoints.push({\n                    index: idx + 1,\n                    point: newSegment,\n                });\n            }\n        });\n        newPoints.forEach((newSegment) =>\n            path.insert(newSegment.index, newSegment.point)\n        );\n\n        if (event.count % OVERCONSTRAIN_FREQUENCY == 1) {\n            const randomIndex = randomInt(0, path.segments.length - 1);\n            const randomNode = path.segments[randomIndex];\n            const newNode = lerp(\n                randomNode.point,\n                randomNode.next.point,\n                random(0.0, 1.0)\n            );\n            path.insert(randomIndex, newNode);\n        }\n        if (debugText)\n            debugText.content = `nodes: ${path.segments.length.toString()}`;\n    };\n    const initEventListeners = () => {\n        document.addEventListener(\"keydown\", (event: KeyboardEvent) => {\n            if ([\" \", \"Spacebar\"].includes(event.key)) {\n                doRender = !doRender;\n            }\n            if ([\"s\"].includes(event.key)) {\n                const svgFile = fileFromSvgElement(\n                    path.exportSVG({\n                        bounds: \"view\",\n                    }) as SVGElement\n                );\n                const linkElement = getDownloadableLink(svgFile);\n                canvas.parentElement\n                    ? canvas.parentElement.appendChild(linkElement)\n                    : document.body.appendChild(linkElement);\n            }\n        });\n    };\n    initEventListeners();\n};\n\nconst range = (n : number) => [...Array(n).keys()]\n\nconst upsamplePath = (path: paper.Path, nSamples : number) : paper.Point[] => \n    range(nSamples)\n        .map(i => path.getPointAt((path.length / nSamples) * i))\n\nexport default differentialGrowth;\n","const createCanvas = (width: number, height: number): HTMLCanvasElement => {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n};\n\nexport default createCanvas;\n","// eslint-disable-next-line no-unused-vars\nimport {\n    Vector3,\n    Mesh,\n    SphereGeometry,\n    MeshPhongMaterial,\n    LineBasicMaterial,\n    Material,\n    MeshToonMaterial,\n    PointsMaterial,\n    MeshBasicMaterial,\n    LineDashedMaterial,\n    MeshPhysicalMaterial,\n} from \"three\";\nimport { random } from \"../utils/random\";\n\nconst walkerRadius = 0.1;\nconst walkerGeometry = new SphereGeometry(walkerRadius, 32, 32);\nconst walkerActiveMaterial = new MeshToonMaterial({ color: 0xce214a });\nconst walkerInactiveMaterial = new MeshToonMaterial({ color: 0x2194ce });\n\nclass Walker {\n    speed: number;\n    body: Mesh<SphereGeometry, Material>;\n    active: boolean;\n    minDistToBranch: number;\n    constructor(\n        speed = 0.01,\n        position = new Vector3(random(-2, 2), random(-2, 2), random(-2, 2))\n    ) {\n        this.body = new Mesh(walkerGeometry, walkerActiveMaterial);\n        this.body.position.x = position.x;\n        this.body.position.y = position.y;\n        this.body.position.z = position.z;\n        this.speed = speed;\n        this.active = true;\n        this.minDistToBranch = 0; // used to avoid checking collisions for every frame\n    }\n\n    walk = () => {\n        this.body.position.x += random(-this.speed, this.speed);\n        this.body.position.y += random(-this.speed, this.speed);\n        this.body.position.z += random(-this.speed, this.speed);\n    };\n\n    collision = (target: Walker) => {\n        const d = this.body.position.distanceTo(target.body.position);\n        const r =\n            this.body.geometry.parameters.radius +\n            target.body.geometry.parameters.radius +\n            this.speed +\n            target.speed;\n        if (d < r) {\n            return true;\n        } else {\n            this.minDistToBranch =\n                d > this.minDistToBranch ? d : this.minDistToBranch;\n        }\n        return false;\n    };\n\n    setInactive = () => {\n        this.active = false;\n        this.body.material = walkerInactiveMaterial;\n        return this;\n    };\n}\n\nexport default Walker;\n","import * as THREE from \"three\";\nimport createCanvas from \"../utils/createCanvas\";\nimport Walker from \"./Walker\";\nimport CameraControls from \"camera-controls\";\nimport { Color } from \"three\";\n\nCameraControls.install({ THREE: THREE });\n\nconst N_WALKERS = 1000;\n\nexport const main = (\n    canvas: HTMLCanvasElement = createCanvas(\n        window.innerWidth,\n        window.innerHeight\n    )\n) => {\n    const renderer = new THREE.WebGLRenderer({ canvas });\n\n    const fov = 75;\n    const aspect = 2; // the canvas default\n    const near = 0.1;\n    const camera = new THREE.PerspectiveCamera(fov, aspect, near);\n    camera.position.z = 8;\n    camera.position.y = 0;\n\n    const clock = new THREE.Clock();\n    const cameraControls = new CameraControls(camera, renderer.domElement);\n\n    const scene = new THREE.Scene();\n    scene.background = new Color(\"white\");\n\n    const color = 0xffffff;\n    const intensity = 1;\n    const light = new THREE.DirectionalLight(color, intensity);\n    light.position.set(-1, 2, 4);\n\n    scene.add(light);\n\n    const speed = 0.02;\n    const minDistThreshold = 3;\n\n    const branch: Walker[] = [new Walker(speed, new THREE.Vector3(0, 0, 0))];\n    const walkers: Walker[] = [];\n    for (let i = 0; i < N_WALKERS; i++) {\n        walkers.push(new Walker(speed));\n    }\n    walkers.map((walker) => scene.add(walker.body));\n\n    let doRender = true;\n    const render = (time: number) => {\n        const delta = clock.getDelta();\n        cameraControls.update(delta);\n\n        renderer.render(scene, camera);\n        requestAnimationFrame(render);\n        if (!doRender) {\n            return;\n        }\n\n        walkers\n            .filter((walker) => walker.active)\n            .map((walker) => {\n                walker.walk();\n                if (walker.minDistToBranch < minDistThreshold) {\n                    branch.forEach((targetWalker) => {\n                        if (walker.collision(targetWalker)) {\n                            branch.push(walker.setInactive());\n                        }\n                    });\n                } else {\n                    walker.minDistToBranch -= walker.speed;\n                }\n            });\n    };\n    const pauseOnSpaceDown = () => {\n        document.addEventListener(\"keydown\", (event: KeyboardEvent) => {\n            if ([\" \", \"Spacebar\"].includes(event.key)) {\n                doRender = !doRender;\n            }\n        });\n    };\n    pauseOnSpaceDown();\n    requestAnimationFrame(render);\n};\n","import differentialGrowth from \"./diff-growth/dg2d\";\nimport createCanvas from \"./utils/createCanvas\";\nimport { main as dla } from \"./dla/dla\";\n\nenum Algorithms {\n    DIFFUSION_LIMITED_AGGREGATION,\n    DIFFERENTIAL_GROWTH,\n}\n\nconst main = (algorithm: Algorithms) => {\n    if (algorithm === Algorithms.DIFFERENTIAL_GROWTH) {\n        const root = document.querySelector(\"#root\");\n        if (!root) throw \"Unable to find root div container\";\n        root.setAttribute(\"style\", \"padding: 1% 2% 0 2%;\");\n\n        const info = document.createElement(\"p\");\n        info.innerText = \"Differential growth\";\n        info.setAttribute(\n            \"style\",\n            \"font-family: Arial; font-size: 18pt; font-weight: bold\"\n        );\n        const canvas = createCanvas(\n            window.innerWidth,\n            window.innerHeight * 0.7\n        );\n        canvas.setAttribute(\"style\", \"display: block;\");\n\n        root.appendChild(info);\n        root.appendChild(canvas);\n\n        differentialGrowth(canvas);\n    } else if (algorithm === Algorithms.DIFFUSION_LIMITED_AGGREGATION) {\n        const canvas = createCanvas(window.innerWidth, window.innerHeight);\n        document.body.appendChild(canvas);\n        dla(canvas);\n    }\n};\nmain(Algorithms.DIFFERENTIAL_GROWTH);\n"],"names":["main","THREE.WebGLRenderer","THREE.PerspectiveCamera","THREE.Clock","THREE.Scene","THREE.DirectionalLight","THREE.Vector3"],"mappings":"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"}