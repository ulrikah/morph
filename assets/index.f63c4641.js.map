{"version":3,"file":"index.f63c4641.js","sources":["../../vite/modulepreload-polyfill","../../src/utils/createCanvas.ts","../../src/utils/shapes.ts","../../src/utils/lerp.ts","../../src/utils/map.ts","../../src/utils/random.ts","../../src/diff-growth/dg2d.ts","../../src/index.ts"],"sourcesContent":["const p = function polyfill() {\n    const relList = document.createElement('link').relList;\n    if (relList && relList.supports && relList.supports('modulepreload')) {\n        return;\n    }\n    for (const link of document.querySelectorAll('link[rel=\"modulepreload\"]')) {\n        processPreload(link);\n    }\n    new MutationObserver((mutations) => {\n        for (const mutation of mutations) {\n            if (mutation.type !== 'childList') {\n                continue;\n            }\n            for (const node of mutation.addedNodes) {\n                if (node.tagName === 'LINK' && node.rel === 'modulepreload')\n                    processPreload(node);\n            }\n        }\n    }).observe(document, { childList: true, subtree: true });\n    function getFetchOpts(script) {\n        const fetchOpts = {};\n        if (script.integrity)\n            fetchOpts.integrity = script.integrity;\n        if (script.referrerpolicy)\n            fetchOpts.referrerPolicy = script.referrerpolicy;\n        if (script.crossorigin === 'use-credentials')\n            fetchOpts.credentials = 'include';\n        else if (script.crossorigin === 'anonymous')\n            fetchOpts.credentials = 'omit';\n        else\n            fetchOpts.credentials = 'same-origin';\n        return fetchOpts;\n    }\n    function processPreload(link) {\n        if (link.ep)\n            // ep marker = processed\n            return;\n        link.ep = true;\n        // prepopulate the load record\n        const fetchOpts = getFetchOpts(link);\n        fetch(link.href, fetchOpts);\n    }\n};__VITE_IS_MODERN__&&p();","const createCanvas = (width : number, height : number, className = 'three-container') : HTMLCanvasElement => {\n  const canvas = document.createElement('canvas')\n  canvas.width = width\n  canvas.height = height\n  canvas.className = className\n  document.body.appendChild(canvas)\n  return canvas\n}\n\nexport default createCanvas\n","import paper from \"paper\";\n\n// draw points in a square based on a radius\nconst pointsAsSquare = (radius : number, nPointsPerSegment : number, center : paper.Point) => {\n    // define the squares\n    const squares : paper.Point[] = [\n        center.clone().add(new paper.Point(radius, -radius)), // top right\n        center.clone().add(new paper.Point(radius, radius)), // bottom right\n        center.clone().add(new paper.Point(-radius, radius)), // bottom left\n        center.clone().add(new paper.Point(-radius, -radius)), // top left\n    ];\n    const points : paper.Point[] = [];\n    [\n        [squares[0], squares[1]],\n        [squares[1], squares[2]],\n        [squares[2], squares[3]],\n        [squares[3], squares[0]],\n    ].map((pair) => {\n        points.push(pair[0]) // push the first square to the list of points\n        const dx = pair[1].x - pair[0].x;\n        const dy = pair[1].y - pair[0].y;\n        for (let i = 0; i < nPointsPerSegment; i++){\n            points.push(\n                new paper.Point(\n                    pair[0].x + (i / nPointsPerSegment) * dx,\n                    pair[0].y + (i / nPointsPerSegment) * dy,\n                )\n            )\n        }\n    })\n    return points\n}\n  \nexport default pointsAsSquare\n  ","import paper from \"paper\";\n\nconst lerp = (a : paper.Point, b : paper.Point, force : number) : paper.Point => {\n    if (force < 0.0 || force > 1.0) throw \"force must be in range [0.0, 1.0]\"\n    const diff = b.subtract(a)\n    return new paper.Point(a.x + force * diff.x, a.y + force * diff.y)\n}\n\nexport default lerp","export const map = (value : number, a: number, b : number, c : number, d : number) => {\n  return (value - a) * (d - c) / (b - a) + c;\n}\n","import { map } from './map';\n\nexport const random = (a: number, b : number) : number => {\n    return map(Math.random(), 0.0, 1.0, a, b);\n}\n\nexport const randomInt = (min : number, max : number) : number => {\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}","import paper from \"paper\";\nimport createCanvas from \"../utils/createCanvas\";\nimport pointsAsSquare from \"../utils/shapes\";\nimport lerp from \"../utils/lerp\";\nimport { random, randomInt } from \"../utils/random\";\n\nconst CONTAINER_NAME = \"dg2d-container\";\n\nconst DISTANCE_THRESHOLD = 3;\nconst ATTRACTION_FORCE = 0.9;\nconst REPULSION_FORCE = 0.5;\nconst ALIGNMENT_FORCE = 0.5;\nconst ADAPTIVE_SUBDIVISION_THRESHOLD = DISTANCE_THRESHOLD * 2;\nconst OVERCONSTRAIN_FREQUENCY = 2; // provided in frames\n\nconst differentialGrowth = () => {\n    const canvas = createCanvas(window.innerWidth, window.innerHeight, CONTAINER_NAME);\n    paper.setup(canvas);\n    let doRender = true;\n\n    const text = new paper.PointText({\n        point : new paper.Point(\n            paper.view.viewSize.width / 10,\n            paper.view.viewSize.height / 5,\n        ),\n        content : `Differential growth`,\n        justification : \"left\",\n        fontSize : 36\n    })\n    const debugText = new paper.PointText({\n        point : new paper.Point(\n            paper.view.viewSize.width / 10,\n            paper.view.viewSize.height / 5 + 50,\n        ),\n        justification : \"left\",\n        fontSize : 24\n    })\n\n    const initialPoints = pointsAsSquare(50, 50, paper.view.center)\n    const path = new paper.Path({ strokeColor : 'black' });\n    path.add(...initialPoints)\n    path.closePath()\n\n    paper.view.onFrame = (event : any) => {\n        if (!doRender) return\n        path.segments.forEach((segment) => {\n            // attract\n            [segment.previous, segment.next].forEach((neighbor) => {\n                const l = lerp(segment.point, neighbor.point, ATTRACTION_FORCE)\n                segment.point.x = l.x\n                segment.point.y = l.y\n            })\n            // repulsion\n            path.segments\n            .filter(otherSegment => otherSegment != segment)\n            .forEach((otherSegment) => {\n                const d = segment.point.getDistance(otherSegment.point);\n                if (d < DISTANCE_THRESHOLD) {\n                    const diff = segment.point.subtract(otherSegment.point);\n                    segment.point.x += diff.x * REPULSION_FORCE\n                    segment.point.y += diff.y * REPULSION_FORCE\n                }\n            })\n            // alignment         \n            const midpoint = lerp(segment.previous.point, segment.next.point, 0.5);\n            const l = lerp(segment.point, midpoint, ALIGNMENT_FORCE);\n            segment.point.x = l.x\n            segment.point.y = l.y\n        })\n        \n        // adaptive suddivision\n        const newPoints : { index : number, point : paper.Point }[] = [];\n        path.curves.forEach((curve, idx) => {\n            if (\n                curve.point1.getDistance(curve.point2) > ADAPTIVE_SUBDIVISION_THRESHOLD\n                && newPoints.every(newPoint => \n                    newPoint.point.getDistance(curve.point1) < ADAPTIVE_SUBDIVISION_THRESHOLD \n                    && newPoint.point.getDistance(curve.point2) < ADAPTIVE_SUBDIVISION_THRESHOLD\n                )\n            ) {\n                const newSegment = curve.getPointAtTime(0.5)\n                newPoints.push({ \n                    index: idx + 1, \n                    point: newSegment\n                })\n            }\n        })\n        newPoints.forEach(newSegment => path.insert(newSegment.index, newSegment.point))\n        \n        if (event.count % OVERCONSTRAIN_FREQUENCY == 1) {\n            const randomIndex = randomInt(0, path.segments.length - 1)\n            const randomNode = path.segments[randomIndex];\n            const newNode = lerp(randomNode.point, randomNode.next.point, random(0.0, 1.0))\n            path.insert(randomIndex, newNode);\n        }\n        debugText.content = `nodes: ${path.segments.length.toString()}`\n    }\n    const initEventListeners = () => {\n        document.addEventListener(\"keydown\", (event: KeyboardEvent) => {\n            if ([\" \", \"Spacebar\"].includes(event.key)) {\n                doRender = !doRender;\n            }\n            if ([\"s\"].includes(event.key)) {\n                doRender = !doRender;\n                const svg = paper.project.exportSVG({ bounds : \"view\" });\n                debugger;\n            }\n        });\n\n\n    };\n    initEventListeners()\n}\n\nexport default differentialGrowth;","// import main from \"./dla/dla\";\n// import differentialGrowth from \"./diff-growth/dg\";\nimport differentialGrowth from \"./diff-growth/dg2d\";\n\n// main();\ndifferentialGrowth();\n"],"names":[],"mappings":"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"}